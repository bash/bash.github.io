+++
title = "Maybe in Î»-calculus"
description = "Read along as I implement the Maybe type and some useful functions for working on Maybe values in Î»-calculus."
authors = ["Ruben"]
+++

I'm currently taking a class on [Models of Computation]. If you're studying at the University of Zurich or ETHZ I highly recommend that you take this class :) You'll get to solve really cool puzzles each week as part of the class.

My favourite model of computation so far is [Lambda Calculus]. As a [functional programming enthusiast], I may be a bit biased thoughâ€¦

Going forward, I will assume that you have some basic knowledge of [Lambda Calculus].

## What is a Maybe?
A `Maybe` value represents an optional value. It can either be present (which we will call `Just`) or absent (which we will call `Nothing`).

`Maybe` goes by many different names depending on the programming language: [Rust] calls it [`Option`], Java [`Optional`] and Haskell calls it [`Maybe`].

If you're interested in learning more about `Maybe` then there's an [excellent introduction by Mark Seemann][ploeh-maybe] targeted at C# developers.

## Intuition
The tricky thing with each model of computation is to build up an intuition of how to solve certain problems in the given model.

Let's look at some other data structures firstâ€”to build up this intuition.
Don't worry, I will not be spoiling any of the exercises from the [Models of Computation] class ;)

### Church Numerals
Church Numerals encode a given natural number `n`, by applying a function `n` times.

The first function application needs some starting value (or *seed*),
so each number is a function that takes two arguments:

```Î»
Î»f.Î»x.EXPR
```

Here are the expressions for the numbers zero to three:
(I'm using `#` to denote comments)
```Î»
Î»f.Î»x.x              # Zero
Î»f.Î»x.f x            # One
Î»f.Î»x.f (f x)        # Two
Î»f.Î»x.f (f (f x))    # Three
```

### Tuples
Tuples are similar to Church Numerals in that tuple values accept some function that they then apply.
In the case of tuples, the function is applied with two arguments: one for the first value of the tuple and one for the second value of the tuple.

So the tuple `(X, Y)` would correspond with the following Î» expression:
```Î»
Î»s.s X Y
```

We can then generalize this to an expression that creates a tuple:
```Î»
Î»a b.Î»s.s a b
# Note that this is equivalent to a function with three arguments:
Î»a b s.s a b
# ... or three functions with one argument each:
Î»a.Î»b.Î»s.s a b
```

Picking out the first or second value is easy: We call our tuple value with a function that picks one of its two arguments.

So picking the first value out of a tuple would look something like this:
```Î»
#           â•­â”€ This is the "constructor" from above
#    â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€ 
  ((Î»a.Î»b.Î»s.s a b) X Y) (Î»a.Î»b.a)
#                         â”€â”€â”€â”¬â”€â”€â”€
#                            â•°â”€  This function  picks out
#                                the first of two arguments
=> (Î»s.s X Y)            (Î»a.Î»b.a)
=> (Î»a.Î»b.a) X Y
=> X
```

Picking out the second value works analogously.

### Booleans
Booleans are encoded as expressions that take two arguments: One that is called when the boolean is true and one that is called when the boolean is false:

```Î»
Î»t f.t   # true
Î»t f.f   # false
```

Let's experiment a bit:
```Î»
#      â•­â”€ an expression that accepts a boolean
#      â”‚         â•­â”€ true
#   â”€â”€â”€â”´â”€â”€â”€â”€   â”€â”€â”´â”€â”€â”€
   (Î»b.b X Y) (Î»t f.t)
#        â”¬ â”¬
#        â”‚ â•°â”€ If false, return Y
#        â•°â”€ If true, return X
=> (Î»t f.t) X Y
=> X

# See, we get X, because the boolean was true.
# Similarly, if we call our expression with false, we will get Y:
   (Î»b.b X Y)(Î»t f.f)
=> (Î»t f.f) X Y
=> Y
```

This looks very promising! Like booleans, `Maybe` values also have two possible states.
Unlike booleans however, one of the statesâ€”`Just`â€”carries a value.

## Implementation
Let's apply our newly gained knowledge to `Maybe`.
Like booleans, our `Maybe` values are expressions of the form:
```Î»
Î»j n.EXPR
```
The first argument `j` will be called when the `Maybe` value is `Just` \
the second argument `n` will be called when the `Maybe` value is `Nothing`.

The `Nothing` value is very straightforward. It's the same as `false`:
<figure class="code-figure">
<figcaption>Nothing</figcaption>


```Î»
Î»j n.n
```

</figure>


`Just` takes an additional first parameter as it has to store a value.

<figure class="code-figure">
<figcaption>Just a</figcaption>

```Î»
Î»a.Î»j n.j a
```

</figure>

You can see that `Just` values call `j` with the stored value.
An instance `Just X` value would look like this:
```Î»
Î»j n.j X
```

Just like with booleans we can decide what to do based on the state of a `Maybe` value:
```Î»
#        â•­â”€ an expression that accepts a Maybe
#        â”‚                â•­â”€ Just X
#   â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€
   (Î»m. m INCR 0) ((Î»a.Î»j n.j a) X)
#         â”€â”¬â”€â”€ â”¬
#          â”‚   â•°â”€ If Nothing, return 0
#          â•°â”€ If Just, increment the value
=> (Î»m. m INCR 0)(Î»j n.j X)
=> (Î»j n.j X) INCR 0
=> INCR X

# Similarly, if we pass in a Nothing value, we get 0:
   (Î»m. m INCR 0)(Î»j n. n)
=> (Î»j n. n) INCR 0
=> 0
```

> ðŸ’­ With a bit of imagination, you could see our `Maybe` value as an implementation of the [Visitor pattern] modulo the separate `Visitor` type.

Writing out these match expressions gets tedious quickly and is not very expressive.
To improve on this, we'll implement some useful functions for working with `Maybe` values.

### `bind`
`bind` takes a `Maybe` value and a `Maybe`-returning function. It applies the function only if the `Maybe` value is `Just`. Otherwise it returns `Nothing`.
You can think of this as a "apply some operation on the value and flatten the `Maybe`s".

<figure class="code-figure">
<figcaption>bind</figcaption>

```Î»
#   â•­â”€ a Maybe value
#   â”‚ â•­â”€ a function that accepts a value and returns a Maybe value
#   â”´ â”´
   Î»m f.m f Nothing
#         â”¬ â”€â”€â”€â”¬â”€â”€â”€
#         â”‚    â•°â”€ If Nothing, return Nothing
#         â•°â”€ If Just, apply the given function
```

</figure>

Perhaps the simplest example is to use `bind` with the `Just` function.
We should get out the same `Maybe` value:

```Î»
   (Î»m.bind m Just) (Just X)
=> bind (Just X) Just
#  â”€â”¬â”€
#   â•°â”€â”€â”€â”€â”€â”€â”€â•®
#   â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€
=> (Î»m f.m f Nothing) (Just X) Just
=> (Just X) Just Nothing
#   â”€â”€â”¬â”€â”€â”€  â”€â”¬â”€â”€ â”€â”€â”€â”¬â”€â”€â”€
#     â•°â”€â”€â”€â•®  â”‚      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
#         â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®          â”‚
#    â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€   â”€â”€â”´â”€â”€â”€
=> ((Î»a.Î»j n.j a) X) (Î»a.Î»j n.j a) (Î»j n.n)
=> (Î»j n.j X) (Î»a.Î»j n.j a) (Î»j n.n)
=> (Î»a.Î»j n.j a) X
=> (Î»j n.j X)
```

As expected, this evaluates to `Just X`.

While this example may not be that interesting,
`bind` is very useful as a tool for implementing more functions.

### `map`
An operation perhaps more commonly used than `bind` is `map`:
It applies a function to the value inside the `Maybe` only if it's present and returns a `Maybe` containing the new value.

<!-- TODO: explain -->
<figure class="code-figure">
<figcaption>lift</figcaption>

```Î»
#   â•­â”€ a function that accepts a single argument
#   â”´ 
   Î»f.Î»x.Just (f x)
```

</figure>

<!-- TODO: explain -->

<figure class="code-figure">
<figcaption>map</figcaption>

```Î»
#   â•­â”€ a Maybe value
#   â”‚ â•­â”€ a function that accepts a regular value
#   â”´ â”´
   Î»m f.bind m (lift f)
```

</figure>

For example, you have a `Maybe` containing some number that you want to multiply by two:

```Î»
#    â•­â”€ a Maybe value containing a number
#    â”‚
#    â”´
   (Î»m.map m TIMES_TWO) (Just X)
=> map (Just X) TIMES_TWO
#  â”€â”¬â”€
#   â•°â”€â”€â”€â”€â”€â”€â”€â”€â•®
#   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
=> (Î»m f.bind m (lift f)) (Just X) TIMES_TWO
#        â”€â”¬â”€â”€    â”€â”¬â”€â”€
#         â”‚       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
#         â•°â”€â”€â”€â”€â”€â”€â•®                     â”‚
#         â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€
=> (Î»m f.(Î»m f.m f Nothing) m ((Î»f.Î»x.Just (f x)) f)) (Just X) TIMES_TWO
=> (Î»m f.m ((Î»f.Î»x.Just (f x)) f) Nothing) (Just X) TIMES_TWO
=> (Î»m f.m (Î»x.Just (f x)) Nothing) (Just X) TIMES_TWO
=> (Just X) (Î»x.Just (TIMES_TWO x)) Nothing
#   â”€â”¬â”€â”€        â”€â”¬â”€â”€                â”€â”€â”€â”¬â”€â”€â”€
#    â”‚           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
#    â•°â”€â”€â”€â”€â•®                     â”‚                           â”‚
#    â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€                  â”€â”€â”€â”´â”€â”€â”€
=> ((Î»a.Î»j n. j a) X) (Î»x.(Î»a.Î»j n. j a) (TIMES_TWO x)) (Î»j n. n)
=> (Î»j n. j X) (Î»x.Î»j n. j (TIMES_TWO x)) (Î»j n. n)
=> (Î»x.Î»j n. j (TIMES_TWO x)) X
=> Î»j n. j (TIMES_TWO X)
```

This is the same as `Just (TIMES_TWO X)`. Yayy it worked âœ¨
We could do a similar demonstration for `Nothing`, but I leave that as an exercise to you dear reader.

### `filter`
Another useful operation on `Maybe` values is `filter`:
`filter` takes a `Maybe` value and a predicate. If the value inside the `Maybe` fulfils the predicate then the `Maybe` value is left unchanged. Otherwise `Nothing` is returned.

Just like with `map`, we can use `bind` as a building block to implement our new function:
<figure class="code-figure">
<figcaption>filter</figcaption>

```Î»
#   â•­â”€ a Maybe value
#   â”‚ â•­â”€ a predicate (i.e. a function that takes a value
#   â”‚ â”‚                    and returns a boolean)
#   â”´ â”´ 
   Î»m p.bind m (Î»x.p x (Just x) Nothing)
#                       â”€â”€â”¬â”€â”€â”€  â”€â”€â”€â”¬â”€â”€â”€
#                         â”‚        â•°â”€ If the predicate does not match,
#                         â”‚           return Nothing
#                         â”‚
#                         â•°â”€ If the predicate matches,
#                            return Just x
```

</figure>

<!-- TODO: filter example, use IS_EVEN as predicate -->

## Outlook
One of my favourite properties of Î»-calculus is the composable nature of expressions.

We could easily build more complicated structures (trees, linked lists, etc.) from the functions discussed in this post. I might write a follow-up post :)

[Models of Computation]: https://co2.ini.uzh.ch/Courses/Models/info.php
[Lambda calculus]: https://en.wikipedia.org/wiki/Lambda_calculus
[Rust]: https://www.rust-lang.org
[functional programming enthusiast]: https://github.com/polyadic/funcky/graphs/contributors
[Visitor pattern]: https://en.wikipedia.org/wiki/Visitor_pattern
[`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
[`Optional`]: https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html
[`Maybe`]: https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html
[ploeh-maybe]: https://blog.ploeh.dk/2022/04/25/the-maybe-monad/
